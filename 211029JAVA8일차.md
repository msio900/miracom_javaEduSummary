# 21.10.29. JAVA-8일차

## 업계 현황

1. 최근 AI와 머신러닝의 급부상으로 개발자 수요가 많아짐
2. 연봉이 많이 오름.
3. 

## 1029 이슈

1. Collection API
2. Exception

## Java Platform

> java 실핼파일이 실행되는 장소

|                      < Java Platform >                       |
| :----------------------------------------------------------: |
| `JDK` : vm 관련 환경변수들이 탑재가 됨.<br />[`JRE`<br />[`JVM`<br />[`스택(Stack)`, `힙(Heap)`, `클래스영역(Class area)`]]] |
|                           운영체제                           |
|                           하드웨어                           |

![구조](./image/1029-01.png)

```java
package com.edu.collection.test;

import java.util.Enumeration;
import java.util.Properties;

public class PropertiesTest1 {
	public static void main(String[] args) {
		//ies는 다 가져옴. 인자 값이 들어있는 것은 나가리
		Properties p = System.getProperties();
		
		Enumeration e = p.propertyNames();
		while(e.hasMoreElements()) {
			String name = (String)e.nextElement();
			String value = p.getProperty(name);
			System.out.println(name+"=========="+value);
		}//while
	}//main
}//class

```

* System.getProperties();
  * 여러 개의 객체가 이미 만들어져 있고, 그것을 가지고 온다는 의미
* = System.getProperties();
  * `=` : 어딘가에 담아야한다는 의미
* Properties p = System.getProperties();
  * `Properties p` 에 할당(담아야 함.)
* 어디에서 생겼는지 모르면 어떻게 뽑아낼지 모름.
  * 데이터들을 어떤 특징으로 담았는지 모른다는 이야기 --> 데이터를 어떻게 뽑아내야 할지 알 수 없음.
* 부모를 찾아라!!

### 객체를 받는 특징

순서가 있음. |	|	|	|	|	|	|	|	|	|

중복이 없음. : 파이썬 튜플 = 자바에서는 set

짝을 이룸. pairing

### collection API

: 여러개의 객체들을 담아내는 인터페이스들의 특징

* 가장 큰 특징은 `Interface`

|                       << Interface >>                        |
| :----------------------------------------------------------: |
| `Collection` : 가장 원시적인 방법으로 객체를 저장하는 특징 - 순서 X / 중복 O |

​										↑- **unique**																			↑ **ordered**(순서가 있는)

|                       << Interface >>                        |      |                       << Interface >>                        |
| :----------------------------------------------------------: | ---- | :----------------------------------------------------------: |
| `Set` : <br />`Collection`다음으로 원시적인 저장법을 가짐.<br />순서 X / 중복 O |      | `List` : <br />시작점과 끝점을 가지면서 환 원형으로 자료를 저장.<br />순서 O 중복 O |

![collection api](./image/1029-02.png)

#### 저장 방식이 다름.

|                       << Interface >>                        |
| :----------------------------------------------------------: |
| `Map` :<br />Key, Value가 쌍(pair)으로 연결되어서 자료를 저장<br />순서 X/ 중복 X (단, value는 중복 O) |

![map 추가](./image/1029-03.PNG)

* List

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | ...  | n    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | c    | d    | e    | f    | g    |      |      |      |

내부적으로 인덱스를 관리 되는 것들은 전부 순서를 가진다!!!

|                       << Interface >>                        |
| :----------------------------------------------------------: |
| `Collection` : 가장 원시적인 방법으로 객체를 저장하는 특징 - 순서 X / 중복 O |

​										↑- **unique**																			↑ **ordered**(순서가 있는)

|                       << Interface >>                        |      |                       << Interface >>                        |
| :----------------------------------------------------------: | ---- | :----------------------------------------------------------: |
| `Set` : <br />`Collection`다음으로 원시적인 저장법을 가짐.<br />순서 X / 중복 O |      | `List` : <br />시작점과 끝점을 가지면서 환 원형으로 자료를 저장.<br />순서 O 중복 O |

​					↑																		↑								↑ 								↑

| <<class>> |      | <<class>> |      | <<class>> |      | <<class>>  |
| :-------: | ---- | :-------: | ---- | :-------: | ---- | :--------: |
|  HashSet  |      |  Vector   |      | ArrayList |      | LinkedList |

#### 

|                       << Interface >>                        |
| :----------------------------------------------------------: |
| `Map` :<br />Key, Value가 쌍(pair)으로 연결되어서 자료를 저장<br />순서 X/ 중복 X (단, value는 중복 O) |

| <<class>> |      | <<class>> |
| :-------: | ---- | :-------: |
| HashTable |      |  HashMap  |

​										↑

|        Properties         |      |      |      |      |
| :-----------------------: | ---- | ---- | ---- | ---- |
| key(String)-value(String) |      |      |      |      |

![collection](./image/1029-04.PNG)

## 동기화 이슈

하나의 쓰레드가 작업을 하는 동안에는 다른 쓰레드가 작업을 못하도록 lock을 걸어둠.

동시 접근 하는 문제를 막음.

A 계좌 

|      |      |      |      |      |
| :--: | ---- | :--: | ---- | :--: |
| $100 |      | $100 |      | $100 |

​																																							↓ 출금 O

B 계좌																																				Locking

​																																							↓  입금 X

|      |
| :--: |
| $100 |

Lock - synchronized



### vector는 Lock이 걸림

| A    | B    | C    | D    | E    | F    |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |

지금은 잘 쓰지 않음. 데이터 입출력 정확도는 굉장히 높지만,,,

엄청난 lock때문에,, 무거움. 성능에 직결되고 성능이 저하됨. 속도가 느려짐.

ArrayList - 99%

|        Vector        |                          ArrayList                           |
| :------------------: | :----------------------------------------------------------: |
| 무거워서 성능이 낮음 | 속도빠르다.<br />데이터 안정성<br />직접 동기화 처리를 걸어야함. |

Vector와 ArrayList



## LinkedList

|  A   |  →   |  B   |  →   |  C   |  →   |  D   |  →   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |


|  A   |  →   |  B   |  →   | C 삭제 |  →   |  D   |  →   |
| :--: | :--: | :--: | :--: | :----: | :--: | :--: | :--: |

* 비 순차적인 데이터의 삭제 추가에 용이함.

![링크드리스트](./image/1029-05.png)

vector - arrayList

HashTable - HashMap

요즘엔 HashMap, ArrayList만 사용

## 코드 분석

```java
//부모가 Map
Properties p = System.getProperties();
		
Enumeration e = p.propertyNames();
while(e.hasMoreElements()) {
    String name = (String)e.nextElement();
    String value = p.getProperty(name);
```

collection API : `HashSet`, `ArrayList`, `HashMap`  - 데이터를 저장하는 방식

데이터를 추출할때, `Enumeration`, `Iterator`

#### ① `key`들을 먼저 뽑고, ② 반복문 안에서 `key`에 해당하는 `value`를 하나씩 뽑으면 됨.

* hasMoreElements()? 있니?
* nextElement() 뽑아내기!
* 이때, String으로 설정! object거등요.
*  p.getProperty(name);
  * value 추출

![코드해석](./image/1029-06.PNG)

